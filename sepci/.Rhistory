if (specie == "Quercus ilex") {
(qi_crown_width(dbh, tree_height) / 2)
}
if (specie == "Quercus pyrenaica") {
return(qp_crown_width(dbh, tree_height) / 2)
}
if (specie == "Pinus sylvestris") {
return(ps_crown_width(dbh, tree_height) / 2)
}
if (specie == "Pinus nigra") {
return(pn_crown_width(dbh, tree_height) / 2)
}
if (specie == "Pinus pinea") {
return(pp_crown_width(dbh, tree_height) / 2)
}
if (specie == "Quercus faginea") {
return(qf_crown_width(dbh, tree_height) / 2)
}
if (specie == "Juniperus thurifera") {
return(jt_crown_width(dbh, tree_height) / 2)
}
}
valdepoza <- valdepoza %>%
rowwise() %>%
mutate(heightLargestCrownRadius =
compute_max_crown_width_heigt(Total_height_m,
Crownbase_height_m),
.before = species) %>%
mutate(largestCrownRadius = compute_crown_width(species,
DBH_cm,
Total_height_m),
.before = species) %>%
ungroup()
colnames(valdepoza) <- c("x", "y", "dbh", "height", "heightStartCrown",
"heightLargestCrownRadius", "largestCrownRadius",
"species")
valdepoza <- ppp(valdepoza$x, valdepoza$y,
c(min(valdepoza$x), max(valdepoza$x)),
c(min(valdepoza$y), max(valdepoza$y)),
marks = valdepoza[, 3:8])
use_data(valdepoza, overwrite = TRUE)
library(siplab)
library(sepci)
library(tidyverse)
data <- valdepoza
# We need a locally parametrized function of crown projection area. This means
# that for each tree we have a function that only takes the height at which we want
# the crown projection area. We use css_cparea_cone that is a helper function
# that assumes that the crown is cone shaped.
tree_csa_functions <- apply(data$marks, 1,
FUN = function(row) {
names(row) <- colnames(valdepoza$marks)
function(x){ccs_cparea_cone(as.numeric(row["heightStartCrown"]),
as.numeric(row["largestCrownRadius"]),
as.numeric(row["height"]), x)}})
data$marks <- data$marks |> mutate(func = tree_csa_functions)
index <- pairwise(data, maxR = 10, kernel = crown_unweighted_cross_fk,
kerpar = list(function_mark = 7,
height_tree_mark = 2,
height_percentage = 50,
alpha = 90))
index
index$marks
sum(is.nan(index$marks))
sum(is.nan(index$marks$cindex))
sum(is.na(index$marks$cindex))
tree_csa_functions <- apply(data$marks, 1,
FUN = function(row) {
names(row) <- colnames(valdepoza$marks)
function(x){ccs_cparea_cone(as.numeric(row["heightStartCrown"]),
as.numeric(row["largestCrownRadius"]),
as.numeric(row["height"]), x)}})
data$marks <- data$marks |> mutate(func = tree_csa_functions)
index <- pairwise(data, maxR = 10, kernel = crown_cross_fk,
kerpar = list(function_mark = 7,
height_tree_mark = 2,
height_percentage = 50))
sum(is.nan(index$marks$cindex))
sum(is.na(index$marks$cindex))
is.na(index$marks$cindex
)
marks <- index$marks
marks
marks <- index$marks[,-c(4,7)]
head(marks)
library(randomForest)
order(c(2,3,1))
library(siplab)
library(TreeCompR)
library(siplab)
a<-c(1,2,3)
b<-c(4,5,6)
arctan(a/b)
atan(a/b)
valdepoza
library(sepci) # we are going to use the data from sepci
valdepoza
valdepoza
pairwise(valdepoza, maxN=3, RK1, kerpar = list(smark='dbh'))
# tree i in a vectorialized way
RK1 <- function(imarks, jmarks, dists, dranks, par= list(smark=1)){
atan(jmarks[smark]/dists)
}
valdepoza
pairwise(valdepoza, maxN=3, RK1, kerpar = list(smark='dbh'))
valdepoza$marks
pairwise(valdepoza, maxN=3, RK1, kerpar = list(smark="dbh"))
RK1 <- function(imarks, jmarks, dists, dranks, par= list(smark=1)){
print("GG")
atan(jmarks[smark]/dists)
}
valdepoza
pairwise(valdepoza, maxN=3, RK1, kerpar = list(smark="dbh"))
valdepoza
pairwise(valdepoza, maxN=3, RK1, kerpar = list(smark=1))
pairwise(valdepoza, maxN=3, kernel=RK1, kerpar = list(smark=1))
RK1 <- function(imarks, jmarks, dists, dranks, par= list(smark=1)){
smark = par$smark
atan(jmarks[smark]/dists)
}
valdepoza
pairwise(valdepoza, maxN=3, kernel=RK1, kerpar = list(smark=1))
RK1 <- function(imarks, jmarks, dists, dranks, par= list(smark=1)){
smark = par$smark
atan(jmarks[smark]/dists)
}
valdepoza
pairwise(valdepoza, maxN=3, kernel=RK1, kerpar = list(smark='dbh'))
results <- pairwise(valdepoza, maxN=3, kernel=RK1, kerpar = list(smark='dbh'))
results$marks
results$marks$cindex
# The data of the trees is in the marks part of the ppp object
heas(valdepoza$marks)
# The data of the trees is in the marks part of the ppp object
head(valdepoza$marks)
head(results$marks)
library(siplab)
library(sepci)
library(siplab)
library(sepci)
# A kernel function is a function that computes the influence of treesj over
# tree i in a vectorialized way. The variables of the function have to be
# imarks, jmarks, dists, dranks, par.
RK1 <- function(imarks, jmarks, dists, dranks, par= list(smark=1)){
smark = par$smark
atan(jmarks[smark]/dists)
}
# We are going to use the data from sepci. The data needs to be in spatstat
# ppp format.
valdepoza
# The data of the trees is in the marks part of the ppp object
head(valdepoza$marks)
# # A tibble: 6 × 6
# dbh height heightStartCrown heightLargestCrownRadius largestCrownRadius species
# <dbl>  <dbl>            <dbl>                    <dbl>              <dbl> <chr>
#   1   6.9    3.5              2.9                     3.01              0.844 Quercus pyrenaica
# 2  45.3   21.3             11                      18.2               0.415 Pinus sylvestris
# 3  29.8   21.1             12.7                    17.5               0.286 Pinus sylvestris
# 4  30.7   20.3             14.4                    15.4               0.325 Pinus sylvestris
# 5  27.6   20.8             14.8                    20.5               0.276 Pinus sylvestris
# 6  26.4   19.8             14.6                    19.5               0.300 Pinus sylvestris
# We want to split the index in intra and inter species competetion.
same_species_sel <- function(imarks, jmarks, dists, dranks, par = list(speciesmark = 1)) {
speciesmark = par$speciesmark
imarks[speciesmark] == jmarks[speciesmark]
}
different_species_sel <- function(imarks, jmarks, dists, dranks, par = list(speciesmark = 1)) {
speciesmark = par$speciesmark
imarks[speciesmark] != jmarks[speciesmark]
}
results_1 <- pairwise(valdepoza, maxN=3, select = same_species_sel,
selpar = list(speciesmark = 'species'),
kernel = RK1,
kerpar = list(smark='dbh'))
3 == c(1,2,3)
same_species_sel <- function(imarks, jmarks, dists, dranks, par = list(speciesmark = 1)) {
speciesmark = par$speciesmark
imarks[[speciesmark]] == jmarks[speciesmark]
}
different_species_sel <- function(imarks, jmarks, dists, dranks, par = list(speciesmark = 1)) {
speciesmark = par$speciesmark
imarks[[speciesmark]] != jmarks[speciesmark]
}
results_1 <- pairwise(valdepoza, maxN=3, select = same_species_sel,
selpar = list(speciesmark = 'species'),
kernel = RK1,
kerpar = list(smark='dbh'))
results_1
results_1$marks$cindex
results_2 <- pairwise(valdepoza, maxN=3, select = different_species_sel,
selpar = list(speciesmark = 'species'),
kernel = RK1,
kerpar = list(smark='dbh'))
results_2$marks$cindex
results_3 <- pairwise(valdepoza, maxN = 3, kernel = RK1,
kerpar = list(smark='dbh'))
results_3 <- pairwise(valdepoza, maxN = 3, kernel = RK1,
kerpar = list(smark='dbh'))
results_3$marks$cindex
results_1$marks$cindex + results_2$marks$cindex == results_3$marks$cindex
results_1$marks$cindex + results_2$marks$cindex - results_3$marks$cindex
results_1$marks$cindex + results_2$marks$cindex == results_3$marks$cindex
all.equal(results_1$marks$cindex + results_2$marks$cindex, results_3$marks$cindex)
# We use all.equal for the comparison to avoid numerical problems
all.equal(results_1$marks$cindex + results_2$marks$cindex, results_3$marks$cindex)
bigger_ind_sel <- function(imarks, jmarks, dists, dranks, par = list(smark = 1)) {
smark = par$smark
imarks[[smark]] < jmarks[smark]
}
smaller_ind_sel <- function(imarks, jmarks, dists, dranks, par = list(smark = 1)) {
smark = par$smark
imarks[[smark]] >= jmarks[smark]
}
# We compute each part separately
results_1 <- pairwise(valdepoza, maxN=3, select = bigger_ind_sel,
selpar = list(smark = 'height'),
kernel = RK1,
kerpar = list(smark='dbh'))
results_1$marks$cindex
results_2 <- pairwise(valdepoza, maxN=3, select = smaller_ind_sel,
selpar = list(smark = 'height'),
kernel = RK1,
kerpar = list(smark='dbh'))
results_2$marks$cindex
# And together
results_3 <- pairwise(valdepoza, maxN = 3, kernel = RK1,
kerpar = list(smark='dbh'))
results_3$marks$cindex
# We can check that the third index should be the sum of the other two
# We use all.equal for the comparison to avoid numerical problems
all.equal(results_1$marks$cindex + results_2$marks$cindex, results_3$marks$cindex)
library(siplab)
library(sepci)
# The data needs to be in ppp format (from spatstat package)
data <- valdepoza
index <- pairwise(valdepoza, maxN = 10, kernel = alemdag,
kerpar = list(dbh_mark="dbh"))
index$marks$cindex
# Just to make output smaller
marks <- index$marks[,-c(5)]
head(index$marks)
library(siplab)
library(sepci)
# The data needs to be in ppp format (from spatstat package)
data <- valdepoza
index <- pairwise(valdepoza, maxN = 10, kernel = alemdag,
kerpar = list(dbh_mark="dbh"))
index$marks$cindex
# Just to make output smaller
marks <- index$marks[,-c(5)]
head(index$marks)
library(siplab)
library(sepci)
# The data needs to be in ppp format (from spatstat package)
data <- valdepoza
index <- pairwise(valdepoza, maxN = 10, kernel = alemdag,
kerpar = list(dbh_mark="dbh"))
index$marks$cindex
# Just to make output smaller
marks <- index$marks[,-c(5)]
head(index$marks)
library(roxygen2)
roxygenise()
install.packages('xfun')
library(roxygen2)
roxygenise()
## code to prepare "valdepoza" dataset goes here
library(usethis)
library(dplyr)
library(tibble)
library(siplab)
set.seed(2)
raw_data <- read.csv("data-raw/Marteloscopes_BiomassBiodiversity_data.csv")
martelo_list <- raw_data %>% group_split(martelo)
valdepoza <- martelo_list [[2]]
# Error correction
temp <- valdepoza$Total_height_m[783]
valdepoza$Total_height_m[783] <- valdepoza$Crownbase_height_m[783]
valdepoza$Crownbase_height_m[783] <- temp
# Error height = crown start height
error_index <- which(valdepoza$Crownbase_height_m ==  valdepoza$Total_height_m)
for(i in error_index){
valdepoza$Crownbase_height_m[i] <- valdepoza$Crownbase_height_m[i] - .5
}
# I want to preserve
# xyposition
# dbh Diameter at breast height in metres
# height Tree height in metres
# heightStartCrown The height were the crown of the tree starts in metres
# heightLargestCrownRadius The height were the crown of the tree
# reachs its maximun radius in metres
# largestCrownRadius The maximun crown radius of the tree in metres
columns_selected <- c("utmX", "utmY", "DBH_cm", "Total_height_m",
"Crownbase_height_m", "species")
valdepoza <- valdepoza [, columns_selected]
# Maximum crown width height equations
# NO EQUATIONS FOR THE MOMENT
compute_max_crown_width_heigt <- function(tree_height, crown_start) {
runif(1, min = crown_start, max = tree_height)
}
# Crown width equations
# "Quercus ilex"
qi_crown_width <- function(dbh, tree_height) {
exp(-1.108 + 0.753 * log(dbh) + 0.176 * log(tree_height))
}
# "Quercus pyrenaica"
qp_crown_width <- function(dbh, tree_height) {
exp(-1.009 + 0.672 * log(dbh) + 0.187 * log(tree_height))
}
# "Pinus sylvestris"
ps_crown_width <-  function(dbh, tree_height) {
# 0.123 changed to -0.123 original equation wrong ¿?
exp(-1.100 + 0.952 * log(dbh) - 0.0314 * log(tree_height) - 0.123
* tree_height)
}
# "Pinus nigra"
pn_crown_width <-  function(dbh, tree_height) {
exp(-1.082 + 0.774 * log(dbh) - 0.0035 * log(tree_height) - 0.114
* tree_height)
}
# "Pinus pinea" # NOTFOUND
pp_crown_width <-  pn_crown_width
# "Quercus faginea"     # NOTFOUND
qf_crown_width <- qp_crown_width
# "Juniperus thurifera" # NOTFOUND
jt_crown_width <-  pn_crown_width
compute_crown_width <- function(specie, dbh, tree_height) {
if (specie == "Quercus ilex") {
(qi_crown_width(dbh, tree_height) / 2)
}
if (specie == "Quercus pyrenaica") {
return(qp_crown_width(dbh, tree_height) / 2)
}
if (specie == "Pinus sylvestris") {
return(ps_crown_width(dbh, tree_height) / 2)
}
if (specie == "Pinus nigra") {
return(pn_crown_width(dbh, tree_height) / 2)
}
if (specie == "Pinus pinea") {
return(pp_crown_width(dbh, tree_height) / 2)
}
if (specie == "Quercus faginea") {
return(qf_crown_width(dbh, tree_height) / 2)
}
if (specie == "Juniperus thurifera") {
return(jt_crown_width(dbh, tree_height) / 2)
}
}
valdepoza <- valdepoza %>%
rowwise() %>%
mutate(heightLargestCrownRadius =
compute_max_crown_width_heigt(Total_height_m,
Crownbase_height_m),
.before = species) %>%
mutate(largestCrownRadius = compute_crown_width(species,
DBH_cm,
Total_height_m),
.before = species) %>%
ungroup()
colnames(valdepoza) <- c("x", "y", "dbh", "height", "heightStartCrown",
"heightLargestCrownRadius", "largestCrownRadius",
"species")
valdepoza <- ppp(valdepoza$x, valdepoza$y,
c(min(valdepoza$x), max(valdepoza$x)),
c(min(valdepoza$y), max(valdepoza$y)),
marks = valdepoza[, 3:8])
use_data(valdepoza, overwrite = TRUE)
roxygenise()
roxygenise()
roxygenise()
library(roxygen2)
roxygenise()
roxygenise()
library(lintr)
library(lintr)
lint_dir()
library(lintr)
lint_dir()
lint_dir()
library(sepci)
valdepoza
valdepoza$marks
pnorm(-3)
pnorm(0)
pnorm(-3)
pnorm(-2)
pnorm(-2)/pnorm(-3)
pnorm(3,lower.tail = TRUE)
pnorm(3,lower.tail = FALSE)
1/720
pnorm(2,lower.tail = FALSE)
pnorm(3,lower.tail = FALSE)*42
pnorm(4,lower.tail = FALSE)
pnorm(4,lower.tail = FALSE)*42
pbinom(.5,60,0.5)
qbinom(.5,60,0.5)
qbinom(.5,60,0.4)
qbinom(.5,60,0.5)
pbinom(30,60,0.5)
pbinom(31,60,0.5)
pbinom(29,60,0.5)
dbinom(30,60,0.5)
dbinom(31,60,0.5)
dbinom(29,60,0.5)
dbinom(60,60,0.5)
dbinom(60,60,0.9)
dbinom(60,60,0.99)
dbinom(60,60,0.97)
dbinom(60,60,0.97)
dbinom(60,60,0.98)
dbinom(60,60,0.985)
dbinom(60,60,0.988)
dbinom(60,60,0.989)
dbinom(60,60,0.9889)
dbinom(60,60,0.9885)
dbinom(60,60,0.9886)
dbinom(60,60,0.98855)
dbinom(60,60,0.98854)
dbinom(60,60,0.98853)
dbinom(60,60,0.98852)
dbinom(60,60,0.98851)
dbinom(60,60,0.988509)
dbinom(60,60,0.988519)
dbinom(60,60,0.988515)
dbinom(60,60,0.988512)
dbinom(60,60,0.988514)
dbinom(60,60,0.9885145)
dbinom(60,60,0.9885144)
dbinom(60,60,0.9885143)
dbinom(60,60,0.9885142)
dbinom(60,60,0.9885141)
dbinom(60,60,0.98851409)
dbinom(60,60,0.98851403)
dbinom(60,60,0.98851401)
dbinom(60,60,0.98851402)
1-0.98851402
1/61
dbinom(2,2,0.9)
dbinom(2,2,0.5)
dbinom(2,2,0.6)
dbinom(2,2,0.7)
dbinom(2,2,0.71)
dbinom(2,2,0.705)
dbinom(2,2,0.72)
dbinom(2,2,0.71)
dbinom(2,2,0.705)
dbinom(2,2,0.703)
dbinom(2,2,0.702)
dbinom(2,2,0.704)
dbinom(2,2,0.705)
dbinom(2,2,0.709)
dbinom(2,2,0.708)
dbinom(2,2,0.707)
1/3
1-1/3
dbinom(100,100,0.9995142)
dbinom(100,100,0.9985142)
dbinom(100,100,0.9885142)
dbinom(100,100,0.9965142)
dbinom(100,100,0.9905142)
dbinom(100,100,0.9955142)
dbinom(100,100,0.9945142)
dbinom(100,100,0.9935142)
dbinom(100,100,0.9925142)
dbinom(100,100,0.9929142)
dbinom(100,100,0.99299)
dbinom(100,100,0.992999)
dbinom(100,100,0.9929999)
dbinom(100,100,0.99299999)
dbinom(100,100,0.993)
dbinom(100,100,0.994)
dbinom(100,100,0.993999)
dbinom(100,100,0.9938)
dbinom(100,100,0.9935)
dbinom(100,100,0.9933)
dbinom(100,100,0.9932)
dbinom(100,100,0.9931)
dbinom(100,100,0.99309)
dbinom(100,100,0.993099)
dbinom(100,100,0.993098)
dbinom(100,100,0.993095)
dbinom(100,100,0.993094)
dbinom(100,100,0.993093)
dbinom(100,100,0.993092)
dbinom(100,100,0.993093)
1-0.993093
1/101
dbinom(60,60,0.98851402)
dbinom(59,60,0.98851402)
dbinom(59,60,0.97851402)
dbinom(59,60,0.99851402)
dbinom(59,60,0.80851402)
dbinom(59,60,0.89851402)
dbinom(59,60,0.99851402)
dbinom(59,60,0.999)
dbinom(59,60,0.9999)
dbinom(59,60,0.99)
dbinom(59,60,0.9)
dbinom(59,60,0.999)
dbinom(59,60,0.98)
dbinom(59,60,0.91)
dbinom(59,60,0.97)
dbinom(59,60,0.98)
dbinom(59,60,0.99)
dbinom(59,60,0.986)
dbinom(59,60,0.987)
dbinom(59,60,0.985)
dbinom(59,60,0.984)
dbinom(59,60,0.9859)
59/60
dbinom(59,60,0.9833333)
