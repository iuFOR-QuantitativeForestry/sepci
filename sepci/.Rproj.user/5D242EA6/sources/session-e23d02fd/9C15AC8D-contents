library(sepci)
library(tidyverse)
tree_csa_functions <- unlist(apply(valdepoza$marks, 1, function(x) {
  return(function(y) {
    return(ccs_cparea_ellipsoid(as.numeric(x[3]), as.numeric(x[4]),
                                as.numeric(x[5]), as.numeric(x[2]),
                                y))})}))
print(head(valdepoza$marks))
valdepoza$marks <- valdepoza$marks %>%
  mutate(csFunction = tree_csa_functions)
height_percentage <- 50
#Package computation
me <- pairwise(valdepoza, maxR = 10, kernel = crown_cross_fk, kerpar =
                 list(function_mark = 7, height_tree_mark = 2,
                      height_percentage = height_percentage))
print("pairs")


ccs_cparea_ellipsoid <- function(height_beginning_crown,
                                 maximum_crown_width_height,
                                 maximum_crown_width_radius,
                                 tree_height,
                                 height_cross_sectional_area) {
  
  # We check if the asked cs height is above or below the
  # maximum crown radius or outside the crown
  print("1")
  if (height_cross_sectional_area > tree_height) {
    return(0)
  }
  
  # The ellipse generated by cutting with plane z=constant is in reality
  # just a circle (because b=c). We need the radius of this circle.
  
  a <- 0
  b <- maximum_crown_width_radius
  
  # We check if the asked cs height is on the upper ellipsoid
  if (height_cross_sectional_area > maximum_crown_width_height) {
    print("2")
    # Axes of upper ellipsoid
    a <- (tree_height - maximum_crown_width_height)
    cut_plane_height <- height_cross_sectional_area - maximum_crown_width_height
    radius <- sqrt(b ^ 2 * (1 - (cut_plane_height ^ 2 / a ^ 2)))
  } else {
    print("3")
    # Axes of lower ellipsoid
    radius <- b
  }

  names(radius) <- NULL
  return(pi * radius ^ 2)
}






