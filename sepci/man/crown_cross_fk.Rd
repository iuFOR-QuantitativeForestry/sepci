% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/competition_kernels.R
\name{crown_cross_fk}
\alias{crown_cross_fk}
\title{Crown cross sectional function kernel}
\usage{
crown_cross_fk(
  imarks,
  jmarks,
  dists,
  dranks,
  par = list(function_mark, height_tree_mark, height_percentage)
)
}
\arguments{
\item{imarks}{Marks for the subject plant, a 1-row data frame.}

\item{jmarks}{Data frame with marks for competitors}

\item{dists}{Vector of distances between the subject plant and the
competitors.}

\item{dranks}{Distance ranks.}

\item{par}{List of parameters.}
}
\value{
Numeric vector of length equal to the length of dists containing the
value of the effect of the competition of each the trees j over the tree i.
}
\description{
This function can be used to implement weighted by distance indexes based
on the crown cross sectional area, crown cross sectional volume or crown
cross sectional surface as described in
\insertCite{dobbertin1992;textual}{sepci}. It can also be used to
implement any distance weighted crown cross sectional index user may imagine.
}
\details{
The values of par are taken from the argument kerpar of pairwise(),
if not NULL.

The first two marks are column numbers of a mark data frame,
function_mark must be the number or name of the column with a function that
gives a trait of the tree at a given height (e.g cross sectional area),
height_tree_mark must be the number or name of the column that contains
the tree height. height_percentage is the percentage of the height of the
tree i that will be used to measure the cross functional trait of all
competitors.

The effect of each tree j is computed following the formula
(f is the given function):
\deqn{\frac{f(tree_j)}{f(tree_i)*distance_{ij}}}
}
\examples{
library(siplab)
library(dplyr)
# Using crown cross sectional volume
tree_csv_functions <- unlist(apply(valdepoza$marks,1,function(x){
return(function(y) {return(ccs_volume_ellipsoid(as.numeric(unlist(x[3])),
                                                as.numeric(unlist(x[4])),
                                                as.numeric(unlist(x[5])),
                                                as.numeric(unlist(x[2])),
                                                y))})}))
valdepoza$marks <- valdepoza$marks \%>\%
mutate(csFunction=tree_csv_functions)
pppiv <- pairwise(valdepoza, maxR = 10, kernel = crown_cross_fk,
kerpar = list(function_mark = 7,height_tree_mark = 2,height_percentage = 50))
}
